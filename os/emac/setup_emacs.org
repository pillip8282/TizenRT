#+TITLE: emacs configuration
#+AUTHOR: pillip
#+EMAIL: kpslen8205@hotmail.com
#+DATE: <2019-04-26 Fri>
#+startup: overview

* interface tweaks
** Basic
I don't know what happens but if I remove this embedded code then elisp command is not called.
So I can't remove below block.
#+BEGIN_SRC emacs-lisp

#+END_SRC

** Useful configurations
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;(if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (scroll-bar-mode -1)
  ;;(if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
  (menu-bar-mode -1)
  (setq inhibit-startup-message t)
  (fset 'yes-or-no-p 'y-or-n-p)
  ;;(if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (tool-bar-mode -1)
  (print "disable tab bar")
#+END_SRC

** Mode Binding
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\Make.defs\\'" . makefile-mode))
  (add-to-list 'auto-mode-alist '("SConstruct" . python-mode))
#+END_SRC
* Key setting
** Global key set
*** Text scale
#+BEGIN_SRC emacs-lisp :tangle yes
  (define-key global-map (kbd "C->") 'text-scale-increase)
  (define-key global-map (kbd "C-<") 'text-scale-decrease)
#+END_SRC

*** Else
#+BEGIN_SRC emacs-lisp :tangle yes
  (print "set global key")
  (global-set-key [C-iso-lefttab] 'previous-buffer)
  (global-set-key [C-tab] 'next-buffer) 
  (global-set-key (kbd "<f5>") 'revert-buffer)
  (global-set-key (kbd "<f4>") 'goto-linez)
  (global-set-key [f7] 'comment-region)
  (global-set-key [f8] 'uncomment-region)
  (global-set-key (kbd "<f11>") 'highlight-symbol-at-point)
  (global-set-key (kbd "C-c k") 'company-search-mode)
  (global-set-key [f9] 'bookmark-set)
  ;;(global-set-key [f12] 'bookmark-bmenu-list)
(global-set-key [f12] 'imenu-list)

  ;;(define-key c-mode-map [f9] 'bookmark-set)
  ;;(define-key c-mode-map [f12] 'bookmark-bmenu-list)
  (print "finish set global key")
#+END_SRC

* try
#+BEGIN_SRC emacs-lisp :tangle yes
	(print "try load")
	(use-package try
	  :ensure t
	  )
#+END_SRC

* which key
Bring up some help
#+BEGIN_SRC emacs-lisp :tangle yes
	(print "which key load")
	(use-package which-key
	  :ensure t
	  :config
	  (which-key-mode)
	  )
#+END_SRC

* Windows configuration
** Tabbar
#+BEGIN_SRC emacs-lisp :tangle yes
     ;; ;; Tabbar
     ;; (use-package tabbar
     ;;   :ensure t
     ;;   :config
     ;;   (tabbar-mode -1))
     ;; ;;     (tabbar-mode -1)
#+END_SRC

* Search Text
** Swiper
#+BEGIN_SRC emacs-lisp :tangle yes
	 ;; (use-package swiper-helm
	 ;;   :ensure t
	 ;;   :bind (("C-s" . swiper-helm)
	 ;; 		 ("C-r" . swiper-helm)
	 ;; 		 ;;		 ("C-c C-r" . ivy-resume)
	 ;; 		 )
	 ;;   :config
	 ;;   (progn
	 ;; 	;;(ivy-mode 1)
	 ;; 	;;(setq ivy-use-virtual-buffers t)
	 ;; 	(setq enable-recursive-minibuffers t)
	 ;; 	;; (global-set-key (kbd "C-s") 'swiper-helm)
	 ;; 	;; (global-set-key (kbd "C-c C-r") 'ivy-resume)
	 ;; 	;; (global-set-key (kbd "<f6>") 'ivy-resume)
	 ;; 	;; (global-set-key (kbd "M-x") 'counsel-M-x)
	 ;; 	;; (global-set-key (kbd "C-x C-f") 'counsel-find-file)
	 ;; 	;; (global-set-key (kbd "<f1> f") 'counsel-describe-function)
	 ;; 	;; (global-set-key (kbd "<f1> v") 'counsel-describe-variable)
	 ;; 	;; (global-set-key (kbd "<f1> l") 'counsel-find-library)
	 ;; 	;; (global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
	 ;; 	;; (global-set-key (kbd "<f2> u") 'counsel-unicode-char)
	 ;; 	;; (global-set-key kbd C-c g 'counsel-git)
	 ;; 	;; (global-set-key (kbd "C-c j") 'counsel-git-grep)
	 ;; 	;; (global-set-key (kbd "C-c k") 'counsel-ag)
	 ;; 	;; (global-set-key (kbd "C-x l") 'counsel-locate)
	 ;; 	;; (global-set-key (kbd "C-S-o") 'counsel-rhythm box)
	 ;; 	;; (define-key minibuffer-local-map (kbd "C-r") 'counsel-minibuffer-history)
	 ;; 	)
	 ;;   )
#+END_SRC

** Ivy
#+BEGIN_SRC emacs-lisp :tangle yes
	 ;; (use-package ivy
	 ;;   :ensure t
	 ;;   :diminish (ivy-mode)
	 ;;   :bind (("C-x b" . ivy-switch-buffer))
	 ;;   :config
	 ;;   (ivy-mode 1)
	 ;;   (setq ivy-use-virtual-buffers t)
	 ;;   (setq ivy-display-style 'fancy)
	 ;;   )
#+END_SRC
* Navigate a code
** avy
avy is a GNU Emacs package for jumping to visible text using a char-based decision tree. See also ace-jump-mode and vim-easymotion avy uses the same idea.
I don't need to use arrow key anymore. I can move to where I want to go by this application.

#+BEGIN_SRC emacs-lisp :tangle yes
	 (use-package avy
	   :bind ("C-c m" . avy-goto-char)
	   )
#+END_SRC
** Ace-windows
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ace-window
    :ensure t
    :init
    (progn
      (global-set-key [remap other-window] 'ace-window)
      (custom-set-faces
       '(aw-leading-char-face
         ((t (:inherit ace-jump-face-foreground :height 3.0)))))
      )
    )

  (defun pk/swap-windows ()
    "Swap windows"
    (interactive)
    (ace-swap-window)
    (aw-flip-window)
    )
  (defun pk/my-windows ()
    "Go to ilist"
    (interactive)
    (print (buffer-name))
    (ace-window 1)
    )
  ;;

(buffer-name)
  (global-set-key (kbd "C-x m") 'pk/swap-windows)
#+END_SRC

* Auto complete
** auto-complete
#+BEGIN_SRC emacs-lisp :tangle yes
     (use-package auto-complete
       :ensure t
       :init
       (progn
         (ac-config-default)
         (global-auto-complete-mode t)
         )
       )
     (use-package auto-complete
       :ensure t
       :config
       (ac-flyspell-workaround) )
#+END_SRC

** company
*** install
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company
    :ensure t
    :config
    (add-hook 'after-init-hook 'global-company-mode)  
    )
  ;;(setq company-backends (delete 'company-semantic company-backends))
  ;;(setq company-backends (delete 'company-clang company-backends))
  ;;(add-to-list 'company-backends 'company-gtags)
  (require 'cc-mode)
  ;;(define-key c-mode-map  [(tab)] 'company-complete)
  ;;(define-key c++-mode-map  [(tab)] 'company-complete)
  (define-key c-mode-map  (kbd "C-c k") 'company-complete)
  (define-key c++-mode-map  (kbd "C-c k") 'company-complete)


#+END_SRC
*** key binding
#+BEGIN_SRC emacs-lisp :tangle yes
(require 'cc-mode)
(define-key c-mode-map (kbd "C-c o") 'company-complete)
(define-key c-mode-map (kbd "C-c i") 'company-gtags)
#+END_SRC
** semantic
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package semantic
  :config
  (global-semanticdb-minor-mode 1)
  (global-semantic-idle-scheduler-mode 1)
  (global-semantic-idle-summary-mode 1) ; display function interface in the minibuffer.
  (add-to-list 'semantic-default-submodes 'global-semantic-stickyfunc-mode)
  (semantic-mode 1)
  )
#+END_SRC
* Add dummy sentence
** lorem-ipsum  
This package provides convenience functions to insert dummy Latin text into a buffer.

* Theme
** color
#+BEGIN_SRC emacs-lisp :tangle yes
	 ;; (use-package color-theme
	 ;;   :ensure t)
#+END_SRC

** zenburn
* Reveal.js
** Link:
  - [[https://github.com/yjwen/org-reveal][Git]]
    #+BEGIN_SRC emacs-lisp :tangle yes
      ;; (use-package ox-reveal
      ;;   :ensure ox-reveal
      ;;   )
      ;; (setq org-reveal-root "http://cdn.jsdelivr.net/reveal.js/3.0.0")
      ;; (setq org-reveal-mathjax t)

      (use-package htmlize
        :ensure t)
    #+END_SRC

* Org
** config
#+BEGIN_SRC emacs-lisp :tangle yes
(setq org-startup-with-inline-images t)
#+END_SRC
** Org-bullets
better display
#+BEGIN_SRC emacs-lisp :tangle yes
	 (use-package org-bullets
	   :ensure t
	   :config
	   (add-hook 'org-mode-hook 'org-bullets-mode))
#+END_SRC

** Org Table
*** Create Table   
org-table-create-convert-from-region
*** Delete a column
kill-rectangle
*** paste a column
yank-rectangle
*** Etc
- org-table-create-or-convert-from-region
- insert '|-' to insert line between row cells
** Capture
set the org directory
#+BEGIN_SRC emacs-lisp :tangle yes
	 (custom-set-variables
	  '(org-directory "~/Workspace/DOCS/orgfiles")
	  '(org-default-notes-file (concat org-directory "/notes.org"))
	  '(org-export-html-postamble nil)
	  '(org-hide-leading-stars t)
	  '(org-startup-folded (quote overview))
	  '(org-startup-indented t)
	  )

	 (setq org-file-apps
		   (append '(
					 ("\\.pdf\\'" . "evince %s")
					 ) org-file-apps)
		   )

	 (global-set-key "\C-ca" 'org-agenda)

	 (setq org-capture-templates
		   '(("a" "Appointment" entry (file  "/home/kang/Workspace/DOCS/orgfiles/gcal.org" "Appointments")
			  "* TODO %?\n:PROPERTIES:\n\n:END:\nDEADLINE: %^T \n %i\n")
			 ("n" "Note" entry (file+headline "~/Workspace/DOCS/orgfiles/notes.org" "Notes")
			  "* Note %?\n%T")
			 ("l" "Link" entry (file+headline "~/Workspace/DOCS/orgfiles/links.org" "Links")
			  "* %? %^L %^g \n%T" :prepend t)
			 ("b" "Blog idea" entry (file+headline "~/Workspace/DOCS/orgfiles/blog.org" "Blog Topics:")
			  "* %?\n%T" :prepend t)
			 ("t" "To Do Item" entry (file+headline "~/Workspace/DOCS/orgfiles/task.org" "To Do Items")
			  "* %?\n%T" :prepend t)
			 ("j" "Journal" entry (file+datetree "~/Workspace/DOCS/journal.org")
			  "* %?\nEntered on %U\n  %i\n  %a")
			 ("s" "Screencast" entry (file "~/Workspace/DOCS/orgfiles/screencastnotes.org")
			  "* %?\n%i\n")))
#+END_SRC

** Auto-completion in Org mode
#+BEGIN_SRC emacs-lisp :tangle yes
	 (use-package org-ac
	   :ensure t
	   :init (progn
			   (require 'org-ac)
			   (org-ac/config-default)
			   )
	   )

	 (global-set-key (kbd "C-c c") 'org-capture)
	 (setq org-agenda-files (list "~/Workspace/DOCS/orgfiles/gcal.org"
								  "_/Workspace/DOCS/orgfiles/i.org"
								  "_/Workspace/DOCS/orgfiles/schedule.org"))
#+END_SRC

** Org-calendar
https://github.com/myuhe/org-gcal.el
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; (use-package org-gcal
  ;;   :ensure t
  ;;   :config
  ;;   (setq org-gcal-client-id "your-id-foo.apps.googleusercontent.com"
  ;; 		org-gcal-client-secret "your-secret"
  ;; 		org-gcal-file-alist '(("your-mail@gmail.com" .  "~/schedule.org")
  ;; 							  ("another-mail@gmail.com" .  "~/task.org")))
  ;;   )
#+END_SRC

** Org-download
Drag images to org-mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org-download
    :ensure t
    :config
    (add-hook 'dired-mode-hook 'org-download-enable))
#+END_SRC
*** Problem
it's not works I don't know why.
*** Alternative
Just download images from web and insert it to an org file
1) Download image
2) add embed code to the org file
   #+BEGIN_SRC comment
   [[file:<file_path>]]
   #+END_SRC
3) If you want see an image on document then toggle to inline mode
   - org-toggle-inline-images

** Org key binding
#+BEGIN_SRC emacs-lisp :tangle yes
  (define-key org-mode-map (kbd "M-S-<up>") 'org-metaup)
  (define-key org-mode-map (kbd "M-S-<down>") 'org-metadown)
#+END_SRC

** Org Inline Image
#+BEGIN_SRC emacs-lisp :tangle yes
(setq org-startup-with-inline-images t)
#+END_SRC

* Smartparens
** Usage
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Package: smartparens
  (use-package smartparens
    :ensure t
    :config
    (setq sp-base-key-bindings 'paredit)
    (setq sp-autoskip-closing-pair 'always)
    (setq sp-hybrid-kill-entire-symbol nil)
    (sp-use-paredit-bindings)
    (show-smartparens-global-mode +1)
    (smartparens-global-mode 1)
    ;; when you press RET, the curly braces automatically
    ;; add another newline
    (sp-with-modes '(c-mode c++-mode)
           (sp-local-pair "{" nil :post-handlers '(("||\n[i]" "RET")))
           (sp-local-pair "/*" "*/" :post-handlers '((" | " "SPC")
                                 ("* ||\n[i]" "RET"))))
    )
#+END_SRC
** Link
- [[https://github.com/Fuco1/smartparens][Homepage]]
* Python
** Python3
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; (setq py-python-command "python3")
  ;; (setq python-shell-interpreter "python3")
#+END_SRC

** Jedi
#+BEGIN_SRC emacs-lisp :tangle yes
	 (use-package jedi
	   :ensure t
	   :init
	   (add-hook 'python-mode-hook 'jedi:setup)
	   (add-hook 'python-mode-hook 'jedi:ac-setup)
	   )
#+END_SRC

** Elpy
#+BEGIN_SRC emacs-lisp
	 (print "loading??? elpy")
	 (use-package elpy
	   :ensure t
	   :config
	   (elpy-enable)
	   (setq python-shell-interpreter "ipython"
			 python-shell-interpreter-args "-i --simple-prompt")
	   (define-key python-mode-map  (kbd "C-c l") 'company-complete)
	   (setq WORKON_HOME "~/Workspace/PYTHON/virtual/")
	   )

#+END_SRC

** Virtual Environment
#+BEGIN_SRC emacs-lisp
	 ;; (use-package virtualenvwrapper
	 ;;   :ensure t
	 ;;   :config
	 ;;   (require 'virtualenvwrapper)
	 ;;   (venv-initialize-interactive-shells) ;; if you want interactive shell support
	 ;;   (venv-initialize-eshell) ;; if you want eshell support
	 ;;   ;; note that setting `venv-location` is not necessary if you
	 ;;   ;; use the default location (`~/.virtualenvs`), or if the
	 ;;   ;; the environment variable `WORKON_HOME` points to the right place
	 ;;   (setq venv-location "~/Workspace/PYTHON/virtual/")
	 ;;   (setenv "WORKON_HOME" "~/Workspace/PYTHON/virtual/")
	 ;;   )
     (setenv "WORKON_HOME" "~/Workspace/PYTHON/VIRTUAL_MACHINE/")
	 (use-package auto-virtualenv
	   :ensure t
	   :config
	   (add-hook 'python-mode-hook 'auto-virtualenv-set-virtualenv)
	   (add-hook 'projectile-after-switch-project-hook 'auto-virtualenv-set-virtualenv)
	   )
#+END_SRC

** Virtual environment
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; (use-package virtualenvwrapper
  ;;       :ensure t
  ;;       :config
  ;;       (venv-initialize-interactive-shells)
  ;;       (venv-initialize-eshell))
#+END_SRC
* Yasnippet
** Yasnippet  
#+BEGIN_SRC emacs-lisp :tangle yes
	 (use-package yasnippet
	   :ensure t
	   :config
	   (yas-global-mode 1)
	   )
#+END_SRC
** Yasnippet-snippets
yasnippet doesn't contain the collections anymore. so I have to get collections by install different package
#+BEGIN_SRC emacs-lisp :tangle yes
	 (use-package yasnippet-snippets
	   :ensure t
	   )
#+END_SRC

* Macro
** Basics
| kmacro-start-macro-or-insert-counter | start recording macro |
| kmacro-end-and-call-macro            | stop recording macro  |
| kmacro-name-last-macro               |                       |
| insert-kbd-macro                     |                       |
** Key bindings
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "<C-f3>") 'kmacro-start-macro-or-insert-counter)
  (global-set-key (kbd "<f3>") 'kmacro-end-and-call-macro)
#+END_SRC
** More
- https://www.gnu.org/software/emacs/manual/html_node/emacs/Keyboard-Macros.html#Keyboard-Macros
- http://ergoemacs.org/emacs/emacs_macro_example.html
- http://emacs-fu.blogspot.com/2010/07/keyboard-macros.html

* Undo-tree
** Commands
| undo-tree-visualize              | show undo-tree            |
| undo-tree-visualizer-toggle-diff | show diff while undo-tree |

** Install
#+BEGIN_SRC emacs-lisp :tangle yes
	(use-package undo-tree
	  :ensure t
	  :init
	  (global-undo-tree-mode)
	  )
#+END_SRC
* Misc packages

** Beacon mode
flashes the cursor's line when you scroll
#+BEGIN_SRC emacs-lisp :tangle yes
	 (use-package beacon
	   :ensure t
	   :config
	   (beacon-mode 1)
	   ;; this color looks good for the zenburn theme but not for the one
	   ;; I'm using for the videos
	   ;; (setq beacon-color "#666600")
	   )
#+END_SRC
** Hungry delete mode
Delete all the whitespace when you hit backspace or delete
#+BEGIN_SRC emacs-lisp :tangle yes
	 (use-package hungry-delete
	   :ensure t
	   :config
	   (global-hungry-delete-mode))
#+END_SRC
** Expand Region
#+BEGIN_SRC emacs-lisp :tangle yes
	 (use-package expand-region
	   :ensure t
	   :config
	   (global-set-key (kbd "C-=") 'er/expand-region);
	   (global-set-key (kbd "C-c b") 'er/contract-region);
	   )
#+END_SRC
** Aggressive mode
It reindents after every change.
*** Links
- [[https://github.com/Malabarba/aggressive-indent-mode][git]]
*** Install
#+BEGIN_SRC emacs-lisp :tangle yes
      ;;(message-box "Set aggressive mode")
      (princ "Set aggressive mode")
      ;; (use-package aggressive-indent
      ;;   :ensure t
      ;;   :config
      ;;   (global-aggressive-indent-mode 1)
      ;;   (add-to-list 'aggressive-indent-excluded-modes 'html-mode)

      ;;   ;; (add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode)
      ;;   ;; (add-hook 'css-mode-hook #'aggressive-indent-mode)
      ;;   )
#+END_SRC

** iedit and narrow / widen dwim
Edit multiple words at a time.
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package iedit
    :ensure t)

  ;; if you're windened, narrow to the region, if you're narrowed, widen
  ;; bound to C-x n
  (defun narrow-or-widen-dwim (p)
    "If the buffer is narrowed, it widens. Otherwise, it narrows intelligently.
  Intelligently means: region, org-src-block, org-subtree, or defun,
  whichever applies first.
  Narrowing to org-src-block actually calls `org-edit-src-code'.

  With prefix P, don't widen, just narrow even if buffer is already
  narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning) (region-end)))
          ((derived-mode-p 'org-mode)
           ;; `org-edit-src-code' is not a real narrowing command.
           ;; Remove this first conditional if you don't want it.
           (cond ((ignore-errors (org-edit-src-code))
                  (delete-other-windows))
                 ((org-at-block-p)
                  (org-narrow-to-block))
                 (t (org-narrow-to-subtree))))
          (t (narrow-to-defun))))

  ;; (define-key endless/toggle-map "n" #'narrow-or-widen-dwim)
  ;; This line actually replaces Emacs' entire narrowing keymap, that's
  ;; how much I like this command. Only copy it if that's what you want.
  (define-key ctl-x-map "n" #'narrow-or-widen-dwim)

#+END_SRC
If you want to edit specific region then you can combine those two commands with iedit.
*** narrow
Restrict editing in this buffer to the current region. The rest of the text becomes temporarily invisible and untouchable but is not deleted	
*** iedit-dwim
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun iedit-dwim (arg)
    "Starts iedit but uses \\[narrow-to-defun] to limit its scope."
    (interactive "P")
    (if arg
        (iedit-mode)
      (save-excursion
        (save-restriction
          (widen)
          ;; this function determines the scope of `iedit-start'.
          (if iedit-mode
              (iedit-done)
            ;; `current-word' can of course be replaced by other
            ;; functions.
            (narrow-to-defun)
            (iedit-start (current-word) (point-min) (point-max)))))))

#+END_SRC
*** widen
Remove restrictions (narrowing) from current buffer. This allows the buffer’s full text to be seen and edited.

** Load other files
#+BEGIN_SRC emacs-lisp :tangle yes
	 (defun load-if-exists (f)
	   "load the elisp file only if it exists and is readable"
	   (if (file-readable-p f)
		   (load-file f)
		 )
	   )
	 ;;(load-if-exists "~/Workspace/test.el")
	 ;;(load-file "file.el")
#+END_SRC

** Others
#+BEGIN_SRC emacs-lisp :tangle yes
	 ;; save before kill ring pkbuild
	 (setq save-interprogram-paste-before-kill t)

	 ;; automatically revert buffer when file is changed outside
	 (global-auto-revert-mode t)
	 (setq auto-revert-verbose nil)

#+END_SRC
* Web mode
major mode for editing web templates
#+BEGIN_SRC emacs-lisp :tangle yes
	;; I haven't developed web programming before so I disable it to save my emacs loading
	;; (use-package web-mode
	;;   :ensure t
	;;   :config
	;;   (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
	;;   (setq web-mode-engines-alist
	;; 		'(("django"    . "\\.html\\'")))
	;;   (setq web-mode-ac-sources-alist
	;; 		'(("css" . (ac-source-css-property))
	;; 		  ("html" . (ac-source-words-in-buffer ac-source-abbrev))))

	;;   (setq web-mode-enable-auto-closing t)
	;;   (setq web-mode-enable-auto-quoting t)) ; this fixes the quote problem I mentioned
#+END_SRC
** link
- http://web-mode.org
* Workgroup
Save a previous window state.
#+BEGIN_SRC emacs-lisp :tangle yes
	(use-package workgroups2
	  :ensure t
	  :config
	  (workgroups-mode 1)
	  )
#+END_SRC

* Multiple-Cursor
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package multiple-cursors
    :ensure t
    :config
    (when (fboundp 'mc/edit-lines)
      (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
      ;;(global-set-key (kbd "C->") 'mc/mark-next-like-this)
      (global-set-key (kbd "C->") 'mc/mark-next-like-this-word)
      (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
      (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)
      )
    (define-key global-map (kbd "H-%") 'mqr-query-replace)
    (define-key global-map (kbd "H-#") 'mqr-query-replace-regexp)
    )
#+END_SRC

* Rectangle
- string-rectangle
- string-insert-rectangle
- kill-rectangle
- yank-rectangle
- open-rectangle
- rectangle mark mode
* Silversearcher
- Install silversearcher on host
#+BEGIN_SRC shell
  apt install silversearcher-ag
#+END_SRC
* Projectile
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package projectile
    :ensure t
    :config
    (projectile-global-mode)
    )
#+END_SRC
** Link
- [[https://projectile.readthedocs.io/en/latest/][projectile documents]]

* dumb-jump
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package dumb-jump
    :bind (("M-g o" . dumb-jump-go-other-window)
           ("M-g j" . dumb-jump-go)
           ("M-g x" . dumb-jump-go-prefer-external)
           ("M-g z" . dumb-jump-go-prefer-external-other-window))
    ;; i don't use ivy
    ;; :config (setq dumb-jump-selector 'ivy)
    :config
    (setq dumb-jump-selector 'helm)
    :ensure t
    :init
    (dumb-jump-mode)
    )
#+END_SRC

* Blog
** Nikola
** prodigy
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; (use-package prodigy
  ;;   :ensure t
  ;;   :config
  ;;   (prodigy-define-service
  ;;    :name "nikola"
  ;;    :command "nikola"
  ;;    :args '("auto")
  ;;    :cwd "/home/kang/gh/kang.github.io"
  ;;    :tags '(glob nikola)
  ;;    :stop-signal 'sigint
  ;;    :kill-process-buffer-on-stop t
  ;;    )
  ;;   )
#+END_SRC
* Kconfig mode
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;; kconfig.el - a major mode for editing linux kernel config (Kconfig) files
  ;; Copyright © 2014 Yu Peng
  ;; Copyright © 2014 Michal Sojka
 
  (defvar kconfig-mode-font-lock-keywords
    '(("^[\t, ]*\\_<bool\\_>" . font-lock-type-face)
      ("^[\t, ]*\\_<int\\_>" . font-lock-type-face)
      ("^[\t, ]*\\_<boolean\\_>" . font-lock-type-face)
      ("^[\t, ]*\\_<tristate\\_>" . font-lock-type-face)
      ("^[\t, ]*\\_<depends on\\_>" . font-lock-variable-name-face)
      ("^[\t, ]*\\_<select\\_>" . font-lock-variable-name-face)
      ("^[\t, ]*\\_<help\\_>" . font-lock-variable-name-face)
      ("^[\t, ]*\\_<---help---\\_>" . font-lock-variable-name-face)
      ("^[\t, ]*\\_<default\\_>" . font-lock-variable-name-face)
      ("^[\t, ]*\\_<range\\_>" . font-lock-variable-name-face)
      ("^\\_<config\\_>" . font-lock-constant-face)
      ("^\\_<comment\\_>" . font-lock-constant-face)
      ("^\\_<menu\\_>" . font-lock-constant-face)
      ("^\\_<endmenu\\_>" . font-lock-constant-face)
      ("^\\_<if\\_>" . font-lock-constant-face)
      ("^\\_<endif\\_>" . font-lock-constant-face)
      ("^\\_<menuconfig\\_>" . font-lock-constant-face)
      ("^\\_<source\\_>" . font-lock-keyword-face)
      ("\#.*" . font-lock-comment-face)
      ("\".*\"$" . font-lock-string-face)))

  (defvar kconfig-headings
    '("bool" "int" "boolean" "tristate" "depends on" "select"
      "help" "---help---" "default" "range" "config" "comment"
      "menu" "endmenu" "if" "endif" "menuconfig" "source"))

  (defun kconfig-outline-level ()
    (looking-at "[\t ]*")
    (let ((prefix (match-string 0))
      (result 0))
      (dotimes (i (length prefix) result)
        (setq result (+ result
                (if (equal (elt prefix i) ?\s)
                1 tab-width))))))

  (define-derived-mode kconfig-mode text-mode
    "kconfig"
    (set (make-local-variable 'font-lock-defaults)
         '(kconfig-mode-font-lock-keywords t))
    (set (make-local-variable 'outline-regexp)
         (concat "^[\t ]*" (regexp-opt kconfig-headings)))
    (set (make-local-variable 'outline-level)
         'kconfig-outline-level))

  (add-to-list 'auto-mode-alist '("Kconfig" . kconfig-mode))
#+END_SRC

* Xterm 256
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package xterm-color
    :ensure t
    :config
    (setq comint-output-filter-functions
          (remove 'ansi-color-process-output comint-output-filter-functions))

    (add-hook 'shell-mode-hook
              (lambda () (add-hook 'comint-preoutput-filter-functions 'xterm-color-filter nil t)))
    )

  (use-package eshell
    :ensure t
    :config
    (add-hook 'eshell-before-prompt-hook
              (lambda ()
                (setq xterm-color-preserve-properties t)))

    (add-to-list 'eshell-preoutput-filter-functions 'xterm-color-filter)
    (setq eshell-output-filter-functions (remove 'eshell-handle-ansi-color eshell-output-filter-functions))
    )

  (setq compilation-environment '("TERM=xterm-256color"))

  (add-hook 'compilation-start-hook
            (lambda (proc)
              ;; We need to differentiate between compilation-mode buffers
              ;; and running as part of comint (which at this point we assume
              ;; has been configured separately for xterm-color)
              (when (eq (process-filter proc) 'compilation-filter)
                ;; This is a process associated with a compilation-mode buffer.
                ;; We may call `xterm-color-filter' before its own filter function.
                (set-process-filter
                 proc
                 (lambda (proc string)
                   (funcall 'compilation-filter proc
                            (xterm-color-filter string)))))))

  ;;  Don't forget to setenv TERM xterm-256color
#+END_SRC
** eterm
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package eterm-256color
    :ensure t
    :config
    (add-hook 'term-mode-hook #'eterm-256color-mode)
    )
#+END_SRC

* ICON
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package all-the-icons
:ensure t)
#+END_SRC
* UML
** PlantUML
*** Dependencies
**** Download jar
**** Install graphviz
graphviz is required if drawing the class diagram
- $ apt install graphviz
*** Install PlantUML pacakge
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package plantuml-mode
    :ensure t
    :config
    (org-babel-do-load-languages 'org-babel-load-languages '((plantuml . t)))
    (setq org-plantuml-jar-path (expand-file-name "/home/kang/.emacs.d/custom/plugin/plantuml.jar"))
    )
#+END_SRC

*** Usage
**** Sequence Diagram
+-------------------------------------+
|#+begin_src plantuml :file           |
|my-diagram.png title Authentication  |
|Sequence                             |
|                                     |
|Alice->Bob: Authentication Request   |
|note right of Bob: Bob thinks about  |
|it Bob->Alice: Authentication        |
|Response #+end_src                   |
+-------------------------------------+
And you can get the result with this command 'org-toggle-inline-image'
**** Class Diagram
|-----------------------------------------------------------------|
| title Hello World                                               |
| scale 600 width                                                 |
| note "An Example of Class Diagram" as NOTE1                     |
|                                                                 |
| interface Interface {                                           |
| public void method1();                                          |
| public void method2();                                          |
| }                                                               |
|                                                                 |
| class NullObject extends Interface                              |
| note bottom of NullObject: refer to design patter "null object" |
| abstract class BaseClass implements Interface {                 |
| private int flag;                                               |
| protected void helper(){...}                                    |
| }                                                               |
| class Concrete1 extends BaseClass                               |
| class Concrete2 extends BaseClass                               |
|-----------------------------------------------------------------|
#+TBLFM: 

*** Link
- [[http://ohyecloudy.com/emacsian/2016/09/28/org-babel-plantuml/][korean tutorial]]
** Web Sequence Diagram
*** Link
- [[https://www.websequencediagrams.com/][homepage]]
*** Install
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package wsd-mode
    :ensure t
    )
#+END_SRC
*** Usage
+----------------------------------------------------------------------+
|#+BEGIN_SRC wsd :file s5j_spi_register_sequence.png :wsd-style vs2010 |
|                                                                      |
|title SPI register sequence in S5J board                              |
|                                                                      |
|participant artik05x_boot.c as a                                      |
|participant s5j_spi.c as s                                            |
|participant spi_uio.c as u                                            |
|                                                                      |
|a->+a: board_spi_initialize                                           |
|note right of a: folder path is                                       |
|/os/board/artik05x/src                                                |
|a->+s: s5j_spi_register                                               |
|s->+s: up_spiinitialize                                               |
|s->+u: spi_uioregister                                                |
|                                                                      |
|#+end_src                                                             |
|                                                                      |
+----------------------------------------------------------------------+
* FONT
** Install nanum font
apt install fonts-nanum-coding
** Setting
#+BEGIN_SRC emacs-lisp :tangle yes
;;(require 'hangul)
;;(when (eq system-type 'gnu-linux)
;;(set-fontset-font t 'hangul (font-spec :name "NanumGothicCoding"))
;;)
(set-fontset-font "fontset-default" '(#x1100 . #xffdc)
                  "NanumGothicOTF-15")
#+END_SRC
* grep
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package wgrep
    :ensure t
    :config
    ;;버퍼를 자동으로 저장
    (setq wgrep-auto-save-buffer t)
    ;;키 바인딩?
    (setq wgrep-enable-key "r")
    ;;읽기전용 버퍼 수정
    (setq wgrep-change-readonly-file t))
#+END_SRC
* Useful commands
** Delete whitespace
: delete-trailing-whitespace
** Wrap Lines
: toggle-truncate-lines
** Get Current file path
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun buffer-kill-path ()
    "copy buffer's full path to kill ring"
    (interactive)
    (kill-new (buffer-file-name)))

  ;;  (define-key c++-mode-map (kbd "C-c C-f") 'buffer-kill-path)
  (define-key global-map (kbd "C-c C-f") 'buffer-kill-path)
#+END_SRC

* Useful links
- [[http://irreal.org/blog/][irreal]]
- [[https://cestlaz.github.io/][tutorial blog]]
(* 1163000 0.97)

* Setup Programming
** Style
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; GROUP: Programming -> Languages -> C

  ;; Available C style:
  ;; “gnu”: The default style for GNU projects
  ;; “k&r”: What Kernighan and Ritchie, the authors of C used in their book
  ;; “bsd”: What BSD developers use, aka “Allman style” after Eric Allman.
  ;; “whitesmith”: Popularized by the examples that came with Whitesmiths C, an early commercial C compiler.
  ;; “stroustrup”: What Stroustrup, the author of C++ used in his book
  ;; “ellemtel”: Popular C++ coding standards as defined by “Programming in C++, Rules and Recommendations,” Erik Nyquist and Mats Henricson, Ellemtel
  ;; “linux”: What the Linux developers use for kernel development
  ;; “python”: What Python developers use for extension modules
  ;; “java”: The default style for java-mode (see below)
  ;; “user”: When you want to define your own style

  ;; activate whitespace-mode to view all whitespace characters
  (global-set-key (kbd "C-c w") 'whitespace-mode)

  ;; show unncessary whitespace that can mess up your diff
  (add-hook 'prog-mode-hook (lambda () (interactive) (setq show-trailing-whitespace 1)))

  ;; use space to indent by default
  (setq-default indent-tabs-mode 1)
  (delete-selection-mode)
  (global-set-key (kbd "RET") 'newline-and-indent)

  ;; set appearance of a tab that is represented by 4 spaces
  (setq-default tab-width 4)
  (setq c-default-style "linux") ; set style to "linux"
  ;;      c-basic-offset 4)
  (setq-default c-basic-offset 4
                tab-width 4
                indent-tabs-mode t)

#+END_SRC
** Compile
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; GROUP: Programming -> Tools -> Compilation ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Compilation from Emacs
  (defun prelude-colorize-compilation-buffer ()
    "Colorize a compilation mode buffer."
    (interactive)
    ;; we don't want to mess with child modes such as grep-mode, ack, ag, etc
    (when (eq major-mode 'compilation-mode)
      (let ((inhibit-read-only t))
        (ansi-color-apply-on-region (point-min) (point-max)))))

  ;; setup compilation-mode used by `compile' command
  (use-package compile
    :ensure t
    :config
    (setq compilation-ask-about-save nil          ; Just save before compiling
          compilation-always-kill t               ; Just kill old compile processes before starting the new one
          compilation-scroll-output 'first-error) ; Automatically scroll to first
    )
  (print "set global key")
  (global-set-key (kbd "<C-f5>") 'compile)

  ;; (global-set-key (kbd "<f5>") (lambda ()
  ;;                                (interactive)
  ;;                                (setq-local compilation-read-command nil)
  ;;                                (call-interactively 'compile)))
#+END_SRC

** Makefile
#+BEGIN_SRC emacs-lisp :tangle yes
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; GROUP: Programming -> Tools -> Makefile
;; takenn from prelude-c.el:48: https://github.com/bbatsov/prelude/blob/master/modules/prelude-c.el
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun prelude-makefile-mode-defaults ()
  (whitespace-toggle-options '(tabs))
  (setq indent-tabs-mode t))

(setq prelude-makefile-mode-hook 'prelude-makefile-mode-defaults)

(add-hook 'makefile-mode-hook (lambda ()
                                (run-hooks 'prelude-makefile-mode-hook)))

;; GROUP: Programming -> Tools -> Ediff
(setq ediff-diff-options "-w"
      ediff-split-window-function 'split-window-horizontally
      ediff-window-setup-function 'ediff-setup-windows-plain)

#+END_SRC

** Diff
*** config
#+BEGIN_SRC emacs-lisp :tangle yes
;; show important whitespace in diff-mode
(add-hook 'diff-mode-hook (lambda ()
                            (setq-local whitespace-style
                                        '(face
                                          tabs
                                          tab-mark
                                          spaces
                                          space-mark
                                          trailing
                                          indentation::space
                                          indentation::tab
                                          newline
                                          newline-mark))
                            (whitespace-mode 1)))
#+END_SRC
*** diff-hl
#+BEGIN_SRC emacs-lisp :tangle yes
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; PACKAGE: diff-hl                             ;;
;;                                              ;;
;; GROUP: Programming -> Tools -> Vc -> Diff Hl ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(use-package diff-hl
  :ensure t
  :config
  (global-diff-hl-mode)
  (add-hook 'dired-mode-hook 'diff-hl-dired-mode)
  )
#+END_SRC
** GIT
#+BEGIN_SRC emacs-lisp :tangle yes
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; PACKAGE: magit                       ;;
;;                                      ;;
;; GROUP: Programming -> Tools -> Magit ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(use-package magit
  :ensure t
  :config
  (set-default 'magit-stage-all-confirm nil)
  (add-hook 'magit-mode-hook 'magit-load-config-extensions)

  ;; full screen magit-status
  (defadvice magit-status (around magit-fullscreen activate)
    (window-configuration-to-register :magit-fullscreen)
    ad-do-it
    (delete-other-windows))

  (global-unset-key (kbd "C-x g"))
  (global-set-key (kbd "C-x g h") 'magit-log)
  (global-set-key (kbd "C-x g f") 'magit-file-log)
  (global-set-key (kbd "C-x g b") 'magit-blame-mode)
  (global-set-key (kbd "C-x g m") 'magit-branch-manager)
  (global-set-key (kbd "C-x g c") 'magit-branch)
  (global-set-key (kbd "C-x g s") 'magit-status)
  (global-set-key (kbd "C-x g r") 'magit-reflog)
  (global-set-key (kbd "C-x g t") 'magit-tag)
  )
#+END_SRC

** Flycheck
*** Flycheck
**** Link
- [[https://www.flycheck.org/en/latest/][Flycheck Website]]
**** Usage
- If you want select syntax checker choose
  - tools -> syntax checking -> select syntax checker
    #+BEGIN_SRC emacs-lisp :tangle yes
     (use-package flycheck
       :ensure t
       :init
       (global-flycheck-mode t)
       :config
       (add-hook 'after-init-hook 'global-flycheck-mode)
       )
    #+END_SRC
*** Flycheck-tip
- GROUP: Flycheck Tip, but just consider it part of Flycheck ;;
- link: https://github.com/yuutayamada/flycheck-tip
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package flycheck-tip
    :ensure t
    :config
                                          ;(flycheck-tip-use-timer 'verbose)
    (define-key prog-mode-map (kbd "C-c C-n") 'flycheck-tip-cycle)
    ;; To avoid echoing error message on minibuffer (optional)
    (setq flycheck-display-errors-function 'ignore)
    (define-key global-map (kbd "C-c C-n") 'error-tip-cycle-dwim)
    (define-key global-map (kbd "C-c C-p") 'error-tip-cycle-dwim-reverse)
    )
#+END_SRC
** magit private
#+BEGIN_SRC emacs-lisp :tangle yes
    (add-hook 'after-make-frame-functions
              (lambda (frame)
                (select-frame frame)
                (cond
                 ((equal (frame-parameter frame 'name) "FM")
                  (dired "~/"))
                 ((equal (frame-parameter frame 'name) "MAGIT")
                  (magit)))))

    (set-frame-name "MAIN")
    ;; 1. that is why we need to explicitly open the file needed here
    ;;(find-file "~/org/files/agenda/TODO.org")

    
    (defun pk/my-git ()
        "Create magit window new frame"
      (interactive)
      (make-frame '((name . "MAGIT")))
      )
  (global-set-key (kbd "C-c g") 'pk/my-git)

#+END_SRC
** GDB
#+BEGIN_SRC emacs-lisp :tangle yes
(setq gdb-many-windows t      ; use gdb-many-windows by default
      gdb-show-main t)        ; Non-nil means display source file containing the main routine at startup

(setq gud-chdir-before-run nil)

#+END_SRC
** EDE
#+BEGIN_SRC emacs-lisp :tangle yes
;(require 'ede)
;(global-ede-mode)
;(ede-cpp-root-project "project_root"
;                      :file "/home/kang/Workspace/EMACS/tutorial/c-demo-project/"
;                      :include-path '("/home/kang/Workspace/EMACS/tutorial/c-demo-project/include1"
;                                      "/home/kang/Workspace/EMACS/tutorial/c-demo-project/include2") ;; add more include
;                      ;; paths here
					;                      :system-include-path '("~/linux"))

#+END_SRC
** Key Binding
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'cc-mode)
  (define-key c++-mode-map (kbd "C-c e") 'iedit-mode)
  (define-key c-mode-map (kbd "C-c e") 'iedit-mode)
#+END_SRC
* Code Browsing
** cscope
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package xcscope
    :ensure t)
#+END_SRC
** GTAG
#+BEGIN_SRC emacs-lisp :tangle yes
(setq-local eldoc-documentation-function #'ggtags-eldoc-function)
#+END_SRC

* Help
** Info
- A quick major mode help with discover-my-major
#+BEGIN_SRC emacs-lisp :tangle yes
(global-unset-key (kbd "C-h h"))        ; original "C-h h" displays "hello world" in different languages
(define-key 'help-command (kbd "h m") 'discover-my-major)
#+END_SRC
** rainbow-mode
#+BEGIN_SRC emacs-lisp :tangle yes
;(add-hook 'html-mode-hook 'rainbow-mode)
;(add-hook 'css-mode-hook 'rainbow-mode)
#+END_SRC
** help+
*** help+
#+BEGIN_SRC emacs-lisp :tangle yes
;;(require 'help+)
#+END_SRC
*** help-fns+
#+BEGIN_SRC emacs-lisp :tangle yes
;;(require 'help-fns+)
#+END_SRC
*** help-mode+
#+BEGIN_SRC emacs-lisp :tangle yes
;;(require 'help-mode+)
#+END_SRC
* Files
** Configuration
#+BEGIN_SRC emacs-lisp :tangle yes
(setq large-file-warning-threshold 100000000) ;; size in bytes

;; automatically refresh dired buffer on changes
(add-hook 'dired-mode-hook 'auto-revert-mode)

;; if it is not Windows, use the following listing switches
(when (not (eq system-type 'windows-nt))
  (setq dired-listing-switches "-lha --group-directories-first"))

;;; KEY BINDINGS.
;; (define-key ctl-x-map "\C-j" 'dired-jump)
;; (define-key ctl-x-4-map "\C-j" 'dired-jump-other-window))
;; (define-key dired-mode-map "\C-x\M-o" 'dired-omit-mode)
;; (define-key dired-mode-map "*O" 'dired-mark-omitted)
;; (define-key dired-mode-map "\M-(" 'dired-mark-sexp)
;; (define-key dired-mode-map "*(" 'dired-mark-sexp)
;; (define-key dired-mode-map "*." 'dired-mark-extension)
;; (define-key dired-mode-map "\M-!" 'dired-smart-shell-command)
;; (define-key dired-mode-map "\M-G" 'dired-goto-subdir)
;; (define-key dired-mode-map "F" 'dired-do-find-marked-files)
;; (define-key dired-mode-map "Y"  'dired-do-relsymlink)
;; (define-key dired-mode-map "%Y" 'dired-do-relsymlink-regexp)
;; (define-key dired-mode-map "V" 'dired-do-run-mail)
;;(require 'dired-x) ; provide extra commands for Dired

#+END_SRC
** Backup
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar backup-directory "~/.backups")
(if (not (file-exists-p backup-directory))
    (make-directory backup-directory t))
(setq
 make-backup-files t        ; backup a file the first time it is saved
 backup-directory-alist `((".*" . ,backup-directory)) ; save backup files in ~/.backups
 backup-by-copying t     ; copy the current file into backup directory
 version-control t   ; version numbers for backup files
 delete-old-versions t   ; delete unnecessary versions
 kept-old-versions 6     ; oldest versions to keep when a new numbered backup is made (default: 2)
 kept-new-versions 9 ; newest versions to keep when a new numbered backup is made (default: 2)
 auto-save-default t ; auto-save every buffer that visits a file
 auto-save-timeout 20 ; number of seconds idle time before auto-save (default: 30)
 auto-save-interval 200 ; number of keystrokes between auto-saves (default: 300)
 )
#+END_SRC
** Dired
*** config
#+BEGIN_SRC emacs-lisp :tangle yes
(setq
 dired-dwim-target t            ; if another Dired buffer is visible in another window, use that directory as target for Rename/Copy
 dired-recursive-copies 'always         ; "always" means no asking
 dired-recursive-deletes 'top           ; "top" means ask once for top level directory
 dired-listing-switches "-lha"          ; human-readable listing
 )
#+END_SRC
*** dired-icons
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package all-the-icons-dired
:ensure t)
#+END_SRC
*** wdired
#+BEGIN_SRC emacs-lisp :tangle yes
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GROUP: Files -> Dired -> Wdired    ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; wdired allows you to edit a Dired buffer and write changes to disk
;; - Switch to Wdired by C-x C-q
;; - Edit the Dired buffer, i.e. change filenames
;; - Commit by C-c C-c, abort by C-c C-k
(use-package wdired
  :ensure t
  :config
  (setq
   wdired-allow-to-change-permissions t   ; allow to edit permission bits
   wdired-allow-to-redirect-links t       ; allow to edit symlinks
   )
  )
#+END_SRC
** Recentf
*** recentf
#+BEGIN_SRC emacs-lisp :tangle yes
(recentf-mode)
(setq
 recentf-max-menu-items 30
 recentf-max-saved-items 5000
 )
#+END_SRC
*** recentf-ext
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package recentf-ext
  :ensure t)
#+END_SRC
** File Browsing
*** treemacs
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package treemacs
    :ensure t
    :defer t
    :init
    (with-eval-after-load 'winum
      (define-key winum-keymap (kbd "M-0") #'treemacs-select-window))
    :config
    (progn
      (setq treemacs-collapse-dirs              (if (executable-find "python") 3 0)
            treemacs-deferred-git-apply-delay   0.5
            treemacs-display-in-side-window     t
            treemacs-file-event-delay           5000
            treemacs-file-follow-delay          0.2
            treemacs-follow-after-init          t
            treemacs-follow-recenter-distance   0.1
            treemacs-goto-tag-strategy          'refetch-index
            treemacs-indentation                2
            treemacs-indentation-string         " "
            treemacs-is-never-other-window      nil
            treemacs-max-git-entries            5000
            treemacs-no-png-images              nil
            treemacs-project-follow-cleanup     nil
            treemacs-persist-file               (expand-file-name ".cache/treemacs-persist" user-emacs-directory)
            treemacs-recenter-after-file-follow nil
            treemacs-recenter-after-tag-follow  nil
            treemacs-show-hidden-files          t
            treemacs-silent-filewatch           nil
            treemacs-silent-refresh             nil
            treemacs-sorting                    'alphabetic-desc
            treemacs-space-between-root-nodes   t
            treemacs-tag-follow-cleanup         t
            treemacs-tag-follow-delay           1.5
            treemacs-width                      35)

      ;; The default width and height of the icons is 22 pixels. If you are
      ;; using a Hi-DPI display, uncomment this to double the icon size.
      ;;(treemacs-resize-icons 44)

      (treemacs-follow-mode t)
      (treemacs-filewatch-mode t)
      (treemacs-fringe-indicator-mode t)
      (pcase (cons (not (null (executable-find "git")))
                   (not (null (executable-find "python3"))))
        (`(t . t)
         (treemacs-git-mode 'extended))
        (`(t . _)
         (treemacs-git-mode 'simple))))
    :bind
    (:map global-map
          ("M-0"       . treemacs-select-window)
          ("C-x t 1"   . treemacs-delete-other-windows)
          ("C-x t t"   . treemacs)
          ("C-x t B"   . treemacs-bookmark)
          ("C-x t C-t" . treemacs-find-file)
          ("C-x t M-t" . treemacs-find-tag)))

  ;; (use-package treemacs-evil
  ;;   :after treemacs evil
  ;;   :ensure t)

#+END_SRC
*** treemacs-projectile
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package treemacs-projectile
  :after treemacs projectile
  :ensure t)
#+END_SRC
*** ztree
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; since ztree works with files and directories, let's consider it in
  ;; group Files
  (push (substitute-in-file-name "path-to-ztree-directory") load-path)
  ;; (use-package ztree-diff
  ;;   :ensure t)
  ;; (use-package ztree-dir
  ;;   :ensure t)
#+END_SRC
*** Neotree
#+BEGIN_SRC emacs-lisp :tangle yes
	;; (use-package neotree
	;;    :config
	;;    (global-set-key [f6] 'neotree-toggle)
	;;   )
#+END_SRC
*** SR Speedbar
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; (use-package sr-speedbar
  ;;   :config
  ;;   (with-eval-after-load "speedbar"
  ;; 	(autoload 'sr-speedbar-toggle "sr-speedbar" nil t)
  ;; 	(global-set-key [f6] 'sr-speedbar-toggle)
  ;; 	)
  ;;   )
#+END_SRC
** File Navigate
*** winmove
- easier window navigation
#+BEGIN_SRC emacs-lisp :tangle yes
(windmove-default-keybindings)
#+END_SRC
** Large Files
*** vlf
- when the file exceed large-file-warning-threshold
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package vlf
  :ensure t
  :config
  (setq vlf-application 'dont-ask)
  )
#+END_SRC
* Face and UI
** config
#+BEGIN_SRC emacs-lisp :tangle yes
;; the blinking cursor is nothing, but an annoyance
(blink-cursor-mode -1)

(setq scroll-margin 0
      scroll-conservatively 100000
      scroll-preserve-screen-position 1)

(size-indication-mode t)

;; more useful frame title, that show either a file or a
;; buffer name (if the buffer isn't visiting a file)
;; taken from prelude-ui.el
(setq frame-title-format
      '("" invocation-name " - " (:eval (if (buffer-file-name)
                                                    (abbreviate-file-name (buffer-file-name))
                                                  "%b"))))

;; change font to Inconsolata for better looking text
;; remember to install the font Inconsolata first
;; pkbuild(setq default-frame-alist '((font . "Consolas")))
;; set italic font for italic face, since Emacs does not set italic
;; face automatically
;(set-face-attribute 'italic nil
;                    :family "Consolas-Regular")

#+END_SRC
** highlight
*** Highlight-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package highlight-symbol
  :ensure t
  :config
  (highlight-symbol-nav-mode)
  (add-hook 'prog-mode-hook (lambda () (highlight-symbol-mode)))
;  (add-hook 'org-mode-hook (lambda () (highlight-symbol-mode)))
  (setq highlight-symbol-idle-delay 0.2
	highlight-symbol-on-navigation-p t)
  (global-set-key [(control shift mouse-1)]
		  (lambda (event)
		    (interactive "e")
		    (goto-char (posn-point (event-start event)))
		    (highlight-symbol-at-point)))
  (global-set-key (kbd "M-n") 'highlight-symbol-next)
  (global-set-key (kbd "M-p") 'highlight-symbol-prev)
  )
#+END_SRC
*** highlight-numbers
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package highlight-numbers
  :ensure t
  :config
  (add-hook 'prog-mode-hook 'highlight-numbers-mode)
  )
#+END_SRC
*** volatile-highlight
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package volatile-highlights
  :ensure t
  :config
  (volatile-highlights-mode t)
  )
#+END_SRC
*** Highlight line mode
Makes it easy to see the line the cursor's on
#+BEGIN_SRC emacs-lisp :tangle yes
	 (global-hl-line-mode t)
#+END_SRC
** duplicate
#+BEGIN_SRC emacs-lisp :tangle yes
;;(require 'duplicate-thing)
;;(global-set-key (kbd "M-c") 'duplicate-thing)
#+END_SRC
** indentation
*** config
#+BEGIN_SRC emacs-lisp :tangle yes
(global-set-key (kbd "RET") 'newline-and-indent)  ; automatically indent when press RET
#+END_SRC
*** clean-aindent-mode
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package clean-aindent-mode
  :ensure t
  :config
  (add-hook 'prog-mode-hook 'clean-aindent-mode)
  )
#+END_SRC
*** dtrt-indent
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package dtrt-indent
  :ensure t
  :config
  (dtrt-indent-mode 1)
  )
#+END_SRC
* External
* Terminal
** config
#+BEGIN_SRC emacs-lisp :tangle yes
;; term-mode, used in M-x term
(defun my-term-setup ()
  (interactive)
  (define-key term-raw-map (kbd "C-y") 'term-send-raw)
  (define-key term-raw-map (kbd "C-p") 'term-send-raw)
  (define-key term-raw-map (kbd "C-n") 'term-send-raw)
  (define-key term-raw-map (kbd "C-s") 'term-send-raw)
  (define-key term-raw-map (kbd "C-r") 'term-send-raw)
  (define-key term-raw-map (kbd "M-w") 'kill-ring-save)
  (define-key term-raw-map (kbd "M-y") 'helm-show-kill-ring)
  (define-key term-raw-map (kbd "M-d") (lambda () (interactive) (term-send-raw-string "\ed")))
  (define-key term-raw-map (kbd "<C-backspace>") (lambda () (interactive) (term-send-raw-string "\e\C-?")))
  (define-key term-raw-map (kbd "M-p") (lambda () (interactive) (term-send-raw-string "\ep")))
  (define-key term-raw-map (kbd "M-n") (lambda () (interactive) (term-send-raw-string "\en")))
  (define-key term-raw-map (kbd "M-,") 'term-send-input)
  (define-key term-raw-map (kbd "C-c y") 'term-paste)
  (define-key term-raw-map (kbd "C-S-y") 'term-paste)
  (define-key term-raw-map (kbd "C-h") nil) ; unbind C-h
  (define-key term-raw-map (kbd "M-x") nil) ; unbind M-x
  (define-key term-raw-map (kbd "C-c C-b") 'helm-mini)
  (define-key term-raw-map (kbd "C-1") 'zygospore-toggle-delete-other-windows)
  (define-key term-raw-map (kbd "C-2") 'split-window-below)
  (define-key term-raw-map (kbd "C-3") 'split-window-right)
  (define-key term-mode-map (kbd "C-0") 'delete-window))
(add-hook 'term-mode-hook 'my-term-setup t)
(setq term-buffer-maximum-size 0)


(require 'term)

;; taken from here: http://www.enigmacurry.com/2008/12/26/emacs-ansi-term-tricks/
(defun visit-ansi-term ()
  "If the current buffer is:
     1) a running ansi-term named *ansi-term*, rename it.
     2) a stopped ansi-term, kill it and create a new one.
     3) a non ansi-term, go to an already running ansi-term
        or start a new one while killing a defunt one"
  (interactive)
  (let ((is-term (string= "term-mode" major-mode))
        (is-running (term-check-proc (buffer-name)))
;;        (term-cmd "/bin/zsh")
        (term-cmd "/bin/bash")
        (anon-term (get-buffer "*ansi-term*")))
    (if is-term
        (if is-running
            (if (string= "*ansi-term*" (buffer-name))
                ;; (call-interactively 'rename-buffer)
                (ansi-term term-cmd)
              (if anon-term
                  (switch-to-buffer "*ansi-term*")
                (ansi-term term-cmd)))
          (kill-buffer (buffer-name))
          (ansi-term term-cmd))
      (if anon-term
          (if (term-check-proc "*ansi-term*")
              (switch-to-buffer "*ansi-term*")
            (kill-buffer "*ansi-term*")
            (ansi-term term-cmd))
        (ansi-term term-cmd)))))

;;(global-set-key (kbd "<f2>") 'visit-ansi-term)

#+END_SRC
** shell-pop
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package shell-pop
  :ensure t
  :config
  (global-set-key (kbd "C-c t") 'shell-pop)
  )
#+END_SRC
* Spell
** flyspell
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; GROUP: Processes -> Flyspell
  (if (executable-find "aspell")
      (progn
        (setq ispell-program-name "aspell")
        ;;(setq ispell-extra-args '("--sug-mode=ultra"))
        )
    (setq ispell-program-name "ispell"))

  ;(add-hook 'text-mode-hook 'flyspell-mode)
  (add-hook 'org-mode-hook 'flyspell-mode)
  ;(add-hook 'prog-mode-hook 'flyspell-prog-mode)
#+END_SRC
* Setting
** config
*** Initialize
#+BEGIN_SRC emacs-lisp :tangle yes
(setq
 inhibit-startup-screen t
 )
#+END_SRC
*** line number
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'prog-mode-hook 'linum-mode) ;; enable linum only in programming modes
#+END_SRC
*** mini buffer
#+BEGIN_SRC emacs-lisp :tangle yes
;; (icomplete-mode)

(setq savehist-additional-variables '(search ring regexp-search-ring) ; also save your regexp search queries
      savehist-autosave-interval 60     ; save every minute
      )
#+END_SRC
*** winner
#+BEGIN_SRC emacs-lisp :tangle yes
(winner-mode 1)
#+END_SRC
*** column line
#+BEGIN_SRC emacs-lisp :tangle yes
(column-number-mode 1)
#+END_SRC
*** revert
#+BEGIN_SRC emacs-lisp :tangle yes
;; update any change made on file to the current buffer
(global-auto-revert-mode)
#+END_SRC
*** whitespace
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'prog-mode-hook (lambda () (interactive) (setq show-trailing-whitespace 1)))
(global-set-key (kbd "C-c w") 'whitespace-mode)
#+END_SRC
** Environment
*** nyan-mode
#+BEGIN_SRC emacs-lisp :tangle yes
;; only turn on if a window system is available
;; this prevents error under terminal that does not support X
(use-package nyan-mode
  :ensure t
  :config
  (case window-system
      ((x w32) (nyan-mode)))
  )

#+END_SRC
*** hippie-expand
- hippie-expand is a better version of dabbrev-expand.
- While dabbrev-expand searches for words you already types, in current;; buffers and other buffers, hippie-expand includes more sources, such as filenames, klll ring...
#+BEGIN_SRC emacs-lisp :tangle yes
(global-set-key (kbd "M-/") 'hippie-expand) ;; replace dabbrev-expand
(setq
 hippie-expand-try-functions-list
 '(try-expand-dabbrev ;; Try to expand word "dynamically", searching the current buffer.
   try-expand-dabbrev-all-buffers ;; Try to expand word "dynamically", searching all other buffers.
   try-expand-dabbrev-from-kill ;; Try to expand word "dynamically", searching the kill ring.
   try-complete-file-name-partially ;; Try to complete text as a file name, as many characters as unique.
   try-complete-file-name ;; Try to complete text as a file name.
   try-expand-all-abbrevs ;; Try to expand word before point according to all abbrev tables.
   try-expand-list ;; Try to complete the current line to an entire line in the buffer.
   try-expand-line ;; Try to complete the current line to an entire line in the buffer.
   try-complete-lisp-symbol-partially ;; Try to complete as an Emacs Lisp symbol, as many characters as unique.
   try-complete-lisp-symbol) ;; Try to complete word as an Emacs Lisp symbol.
 )
#+END_SRC
*** savespace
- saveplace remembers your location in a file when saving files
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package saveplace
    :config
    (setq-default save-place t)
    )
    ;(toggle-save-place-globally 1)
#+END_SRC
*** ibuffer
#+BEGIN_SRC emacs-lisp :tangle yes

#+END_SRC
**** config
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-x C-b") 'ibuffer)
  (setq ibuffer-saved-filter-groups
        (quote (("home"
                 ("dired" (mode . dired-mode))
                 ("org" (name . "^.*org$"))
                 ("C code" (or (mode . c++-mode) (mode . c-mode) (name . "\*cpp") (name . "\*\.h") (name . "\*c") ))
                 ("web" (or (mode . web-mode) (mode . js2-mode)))
                 ("shell" (or (mode . eshell-mode) (mode . shell-mode)))
                 ("mu4e" (name . "\*mu4e\*"))
                 ("programming" (or (mode . python-mode)))
                 ("emacs-config" (or (filename . ".emacs.d")
                                     (filename . "emacs-config")))
                 ("emacs" (or
                           (name . "^\\*scratch\\*$")
                           (name . "^\\*Messages\\*$")))
                 ("Help" (or (name . "\*Help\*")
                             (name . "\*Apropos\*")
                             (name . "\*info\*")))
                 ))))
  (add-hook 'ibuffer-mode-hook
            (lambda ()
              (ibuffer-auto-mode 1)
              (ibuffer-switch-to-saved-filter-groups "home")))

  ;; don't show these
                                          ;(add-to-list 'ibuffer-never-show-predicates "zowie")
  ;; Don't show filter groups if there are no buffers in that group
  (setq ibuffer-show-empty-filter-groups nil)

  ;; Don't ask for confirmation to delete marked buffers
  (setq ibuffer-expert t)
  (setq ibuffer-use-other-window t) ;; always display ibuffer in another window

  (add-hook 'ibuffer-hook
            (lambda ()
              (ibuffer-vc-set-filter-groups-by-vc-root)
              (unless (eq ibuffer-sorting-mode 'alphabetic)
                (ibuffer-do-sort-by-alphabetic))))

  (setq ibuffer-formats
        '((mark modified read-only  " " 
                (name 18 18 :left :elide)
                " "
                (size 9 -1 :right)
                " "
                (mode 16 16 :left :elide)
                " "
                filename-and-process)))
#+END_SRC
**** link
- [[http://martinowen.net/blog/2010/02/03/tips-for-emacs-ibuffer.html][blog]]
*** golden ratio
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; (defun pl/helm-alive-p ()
  ;;   (if (boundp 'helm-alive-p)
  ;;       (symbol-value 'helm-alive-p)))

  ;; (use-package golden-ratio
  ;;   :ensure t
  ;;   :config
  ;;   (add-to-list 'golden-ratio-exclude-modes "ediff-mode")
  ;;   (add-to-list 'golden-ratio-exclude-modes "helm-mode")
  ;;   (add-to-list 'golden-ratio-exclude-modes "dired-mode")
  ;;   (add-to-list 'golden-ratio-exclude-modes "speedbar-mode")
  ;;   (add-to-list 'golden-ratio-exclude-modes "compilation-mode")
  ;;   (add-to-list 'golden-ratio-inhibit-functions 'pl/helm-alive-p)

  ;;   ;; do not enable golden-raio in thses modes
  ;;   (setq golden-ratio-exclude-modes '("ediff-mode"
  ;; 				     "gud-mode"
  ;; 				     "gdb-locals-mode"
  ;; 				     "gdb-registers-mode"
  ;; 				     "gdb-breakpoints-mode"
  ;; 				     "gdb-threads-mode"
  ;; 				     "gdb-frames-mode"
  ;; 				     "gdb-inferior-io-mode"
  ;; 				     "gud-mode"
  ;; 				     "gdb-inferior-io-mode"
  ;; 				     "gdb-disassembly-mode"
  ;; 				     "gdb-memory-mode"
  ;; 				     "magit-log-mode"
  ;; 				     "magit-reflog-mode"
  ;; 				     "magit-status-mode"
  ;; 				     "IELM"
  ;; 				     "eshell-mode"
  ;; 				     "dired-mode"
  ;; 				     "speedbar-frame-mode"))

  ;;   (golden-ratio-mode)
  ;;   )
#+END_SRC
** Garbage collection
#+BEGIN_SRC emacs-lisp :tangle yes
(setq gc-cons-threshold 100000000)
#+END_SRC
* Edit
** config
#+BEGIN_SRC emacs-lisp :tangle yes
(setq global-mark-ring-max 5000         ; increase mark ring to contains 5000 entries
      mark-ring-max 5000                ; increase kill ring to contains 5000 entries
      mode-require-final-newline t      ; add a newline to end of file
      )

;; GROUP: Editing -> Killing
(setq
 kill-ring-max 5000 ; increase kill-ring capacity
 kill-whole-line t  ; if NIL, kill whole line and move the next line up
 )

#+END_SRC
** Encoding
#+BEGIN_SRC emacs-lisp :tangle yes
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-language-environment "UTF-8")
(prefer-coding-system 'utf-8)

(set-language-environment "Korean")
(prefer-coding-system 'utf-8)
#+END_SRC
** goto-address
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'prog-mode-hook 'goto-address-mode)
(add-hook 'text-mode-hook 'goto-address-mode)
#+END_SRC
** Adaptive-Wrap
- Show a nice new line
  #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package adaptive-wrap
     :ensure t
     :config
     (when (fboundp 'adaptive-wrap-prefix-mode)
       (defun my-activate-adaptive-wrap-prefix-mode ()
         "Toggle `visual-line-mode' and `adaptive-wrap-prefix-mode' simultaneously."
         (adaptive-wrap-prefix-mode (if visual-line-mode 1 -1)))
       (add-hook 'visual-line-mode-hook 'my-activate-adaptive-wrap-prefix-mode))
     )
  #+END_SRC
** Markdown
*** markdown
#+BEGIN_SRC emacs-lisp :tangle yes
	(use-package markdown-mode
	  :ensure t
	  :commands (markdown-mode gfm-mode)
	  :mode (("README\\.md\\'" . gfm-mode)
			 ("\\.md\\'" . markdown-mode)
			 ("\\.markdown\\'" . markdown-mode))
	  :init (setq markdown-command "multimarkdown"))
#+END_SRC
*** Flymd
On the fly markdown preview
**** Link
- [[https://github.com/mola-T/flymd][Homepage]]
  #+BEGIN_SRC emacs-lisp :tangle yes
	 (use-package flymd
	   :ensure t)
  #+END_SRC
** Bookmark
*** Quick Bookmark
- Bookmark with "C-S b" 
  #+BEGIN_SRC emacs-lisp :tangle yes
    (defun my/quick-save-bookmark ()
      "Save bookmark with name as 'buffer:row:col'"
      (interactive)
      (bookmark-set (format "%s:%s:line %s:column %s"
                            (thing-at-point 'symbol)
                            (buffer-name)
                            (line-number-at-pos)
                            (current-column)))
      (message "Bookmarked saved at current position"))

    (global-set-key (kbd "C-S-b") 'my/quick-save-bookmark)

  #+END_SRC
* Code Navigate
** Window cycling
#+BEGIN_SRC emacs-lisp :tangle yes
	 ;; (defun windmove-up-cycle()
	 ;;   (interactive)
	 ;;   (condition-case nil (windmove-up)
	 ;; 	(error (condition-case nil (windmove-down)
	 ;; 			 (error (condition-case nil (windmove-right) (error (condition-case nil (windmove-left) (error (windmove-up))))))))))

	 ;; (defun windmove-down-cycle()
	 ;;   (interactive)
	 ;;   (condition-case nil (windmove-down)
	 ;; 	(error (condition-case nil (windmove-up)
	 ;; 			 (error (condition-case nil (windmove-left) (error (condition-case nil (windmove-right) (error (windmove-down))))))))))

	 ;; (defun windmove-right-cycle()
	 ;;   (interactive)
	 ;;   (condition-case nil (windmove-right)
	 ;; 	(error (condition-case nil (windmove-left)
	 ;; 			 (error (condition-case nil (windmove-up) (error (condition-case nil (windmove-down) (error (windmove-right))))))))))

	 ;; (defun windmove-left-cycle()
	 ;;   (interactive)
	 ;;   (condition-case nil (windmove-left)
	 ;; 	(error (condition-case nil (windmove-right)
	 ;; 			 (error (condition-case nil (windmove-down) (error (condition-case nil (windmove-up) (error (windmove-left))))))))))

	 ;; (global-set-key (kbd "C-c y") 'windmove-up-cycle)
	 ;; (global-set-key (kbd "C-c n") 'windmove-down-cycle)
	 ;; (global-set-key (kbd "C-c g") 'windmove-left-cycle)
	 ;; (global-set-key (kbd "C-c j") 'windmove-right-cycle)
#+END_SRC
** Smart move to beginning of line
- Move point back to indentation of beginning of line. Move point to the first non-whitespace character on this line. If point is already there, move to the beginning of the line. Effectively toggle between the first non-whitespace character and the beginning of the line. If ARG is not nil or 1, move forward ARG - 1 lines first.  If point reaches the beginning or end of the buffer, stop there.
  #+BEGIN_SRC emacs-lisp :tangle yes
	 (defun smarter-move-beginning-of-line (arg)
	   (interactive "^p")
	   (setq arg (or arg 1))

	   ;; Move lines first
	   (when (/= arg 1)
		 (let ((line-move-visual nil))
		   (forward-line (1- arg))))

	   (let ((orig-point (point)))
		 (back-to-indentation)
		 (when (= orig-point (point))
		   (move-beginning-of-line 1))))

	 ;; remap C-a to `smarter-move-beginning-of-line'
	 (global-set-key [remap move-beginning-of-line]
					 'smarter-move-beginning-of-line)
  #+END_SRC

* ELDOC
** config
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
(add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
(add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)
#+END_SRC

* Folding
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'c-mode-common-hook   'hs-minor-mode)

#+END_SRC

* Shell
** Better Shell
This package simplifies shell management and sudo access by providing the following commands.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package better-shell
      :ensure t
      :bind (("C-'" . better-shell-shell)
         ("C-;" . better-shell-remote-open)))
#+END_SRC
** eshell
*** config
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'eshell)
  (require 'em-alias)
  (require 'cl)

  ;; Advise find-file-other-window to accept more than one file
  (defadvice find-file-other-window (around find-files activate)
    "Also find all files within a list of files. This even works recursively."
    (if (listp filename)
        (loop for f in filename do (find-file-other-window f wildcards))
      ad-do-it))

  ;; In Eshell, you can run the commands in M-x
  ;; Here are the aliases to the commands.
  ;; $* means accepts all arguments.
  (eshell/alias "o" "")
  (eshell/alias "o" "find-file-other-window $*")
  (eshell/alias "vi" "find-file-other-window $*")
  (eshell/alias "vim" "find-file-other-window $*")
  (eshell/alias "emacs" "find-file-other-windpow $*")
  (eshell/alias "em" "find-file-other-window $*")

  (add-hook
   'eshell-mode-hook
   (lambda ()
     (setq pcomplete-cycle-completions nil)))

  ;; change listing switches based on OS
  (when (not (eq system-type 'windows-nt))
    (eshell/alias "ls" "ls --color -h --group-directories-first $*"))

#+END_SRC
*** user-define
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun eshell/clear ()
    "04Dec2001 - sailor, to clear the eshell buffer."
    (interactive)
    (let ((inhibit-read-only t))
      (erase-buffer)))
#+END_SRC

* Theme
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package monokai-theme
    :ensure t
    )
#+END_SRC
* Ztree
* Imenu
** imenu-list
#+BEGIN_SRC emacs-lisp :tangle yes
  (print "imenu list")

  (use-package imenu-list
    :ensure t
    :config
    (setq imenu-list-focus-after-activation nil)
    (setq imenu-list-auto-resize nil)
    (setq imenu-list-size 0.12)
    (setq imenu-list-position 'left)
    (imenu-list-minor-mode)
    (setq imenu-list-after-jump-hook nil)
    (add-hook 'imenu-list-after-jump-hook #'recenter-top-bottom)
    )


#+END_SRC
** imenu-anywhere
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package imenu-anywhere
:ensure t)
#+END_SRC
* Helm
** helm
#+BEGIN_SRC emacs-lisp :tangle yes
(print "install helm")
  (use-package helm
    :ensure t
    :config
    (setq helm-idle-delay 0.1)
    (setq helm-input-idle-delay 0.1)
    (require 'helm-config)
    )

  ;; (use-package helm-config
  ;;   :ensure t)

  ;; The default "C-x c" is quite close to "C-x C-c", which quits Emacs.
  ;; Changed to "C-c h". Note: We must set "C-c h" globally, because we
  ;; cannot change `helm-command-prefix-key' once `helm-config' is loaded.

  (setq helm-split-window-in-side-p           t ; open helm buffer inside current window, not occupy whole other window
        helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
        helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
        helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
        helm-ff-file-name-history-use-recentf t
        helm-echo-input-in-header-line t)

  (helm-mode 1)
(print "install helm done")
#+END_SRC
** config
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'helm-sources-using-default-as-input 'helm-source-man-pages)
                                          ;(setq helm-semantic-fuzzy-match t
                                          ;      helm-imenu-fuzzy-match    t)
                                          ;(setq helm-locate-fuzzy-match t)
  (when (executable-find "ack-grep")
    (setq helm-grep-default-command "ack-grep -Hn --no-group --no-color %e %p %f"
          helm-grep-default-recurse-command "ack-grep -H --no-group --no-color %e %p %f"))

  (setq helm-buffers-fuzzy-matching t
        helm-recentf-fuzzy-match    t)
  (setq helm-M-x-fuzzy-match t) ;; optional fuzzy matching for helm-M-x
  (when (executable-find "curl")
    (setq helm-google-suggest-use-curl-p t))

#+END_SRC
** helm-gtag
#+BEGIN_SRC emacs-lisp :tangle yes
  (print "gtag helm")
  (use-package helm-gtags
    :ensure t
    :config
    (setq
     helm-gtags-ignore-case t
     helm-gtags-auto-update t
     helm-gtags-use-input-at-cursor t
     helm-gtags-pulse-at-cursor t
     helm-gtags-prefix-key "\C-cg"
     helm-gtags-suggested-key-mapping t
     )
    :config
    (add-hook 'dired-mode-hook 'helm-gtags-mode)
    (add-hook 'eshell-mode-hook 'helm-gtags-mode)
    (add-hook 'c-mode-hook 'helm-gtags-mode)
    (add-hook 'c++-mode-hook 'helm-gtags-mode)
    (add-hook 'asm-mode-hook 'helm-gtags-mode)

    (define-key helm-gtags-mode-map (kbd "C-c g a") 'helm-gtags-tags-in-this-function)
    (define-key helm-gtags-mode-map (kbd "C-j") 'helm-gtags-select)
    (define-key helm-gtags-mode-map (kbd "M-.") 'helm-gtags-dwim)
    (define-key helm-gtags-mode-map (kbd "M-,") 'helm-gtags-pop-stack)
    (define-key helm-gtags-mode-map (kbd "C-c <") 'helm-gtags-previous-history)
    (define-key helm-gtags-mode-map (kbd "C-c >") 'helm-gtags-next-history)
    )
(print "gtag helm done")
#+END_SRC
** helm-ag
#+BEGIN_SRC emacs-lisp :tangle yes
(print "helm ag")
  (use-package helm-ag
    :ensure t
    :config
    (custom-set-variables
     '(helm-ag-base-command "ag --nocolor --nogroup --ignore-case")
     '(helm-ag-command-option "--all-text")
     '(helm-ag-insert-at-point 'symbol)
     '(helm-ag-ignore-buffer-patterns '("\\.txt\\'" "\\.mkd\\'")))
    )
(print "helm ag done")
#+END_SRC
** helm-projectile
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package helm-projectile
    :ensure t
    :config
    (helm-projectile-on)
    (setq projectile-switch-project-action 'helm-projectile)
    (print "helm-projectile")
    (projectile-global-mode)
    (setq projectile-completion-system 'helm)
    (setq projectile-indexing-method 'alien)
    (setq projectile-enable-caching t)
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
    )
  (print "helm projectile done")
#+END_SRC
** helm-swoop
#+BEGIN_SRC emacs-lisp :tangle yes
(print "helm swoop")
  (use-package helm-swoop
    :ensure t)
(print "helm swoop done")
#+END_SRC
** helm-cscope
#+BEGIN_SRC emacs-lisp :tangle yes
(print "helm cscope")
	 ;; (use-package helm-cscope
	 ;;   :ensure t
	 ;;   )
(print "helm cscope done")
#+END_SRC
** helm configurations
#+BEGIN_SRC emacs-lisp :tangle yes
  (print "auto resize mode on")
  (setq helm-autoresize-max-height 25)
  (setq helm-autoresize-min-height 25)
  (helm-autoresize-mode 1)
#+END_SRC
** user-define functions
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun shk-yas/helm-prompt (prompt choices &optional display-fn)
    "Use helm to select a snippet. Put this into `yas-prompt-functions.'"
    (interactive)
    (setq display-fn (or display-fn 'identity))
    (if (require 'helm-config)
        (let (tmpsource cands result rmap)
          (setq cands (mapcar (lambda (x) (funcall display-fn x)) choices))
          (setq rmap (mapcar (lambda (x) (cons (funcall display-fn x) x)) choices))
          (setq tmpsource
                (list
                 (cons 'name prompt)
                 (cons 'candidates cands)
                 '(action . (("Expand" . (lambda (selection) selection))))
                 ))
          (setq result (helm-other-buffer '(tmpsource) "*helm-select-yasnippet"))
          (if (null result)
              (signal 'quit "user quit!")
            (cdr (assoc result rmap))))
      nil))

  (defun spacemacs//helm-hide-minibuffer-maybe ()
    "Hide minibuffer in Helm session if we use the header line as input field."
    (when (with-helm-buffer helm-echo-input-in-header-line)
      (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
        (overlay-put ov 'window (selected-window))
        (overlay-put ov 'face
                     (let ((bg-color (face-background 'default nil)))
                       `(:background ,bg-color :foreground ,bg-color)))
        (setq-local cursor-type nil))))

  (add-hook 'helm-minibuffer-set-up-hook
            'spacemacs//helm-hide-minibuffer-maybe)

#+END_SRC
** key binding
*** general
#+BEGIN_SRC emacs-lisp :tangle yes
  (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to run persistent action
  (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB work in terminal
  (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z

  (global-set-key (kbd "M-x") 'helm-M-x)
  (global-set-key (kbd "M-y") 'helm-show-kill-ring)
  (global-set-key (kbd "C-x b") 'helm-mini)
  (global-set-key (kbd "C-x C-f") 'helm-find-files)

  (global-set-key (kbd "C-c h") 'helm-command-prefix)
  (global-unset-key (kbd "C-x c"))
  (global-set-key (kbd "C-h SPC") 'helm-all-mark-rings)
  (global-set-key (kbd "C-c h x") 'helm-register)
  (global-set-key (kbd "C-c h M-:") 'helm-eval-expression-with-eldoc)

  ;;(global-set-key [f12] 'helm-bookmark)

  (with-eval-after-load 'helm-gtags
    (define-key helm-gtags-mode-map (kbd "M-]") 'helm-gtags-resume)
    )
  (bind-key "<menu>" 'helm-bookmark)
#+END_SRC
*** helm-occur
#+BEGIN_SRC emacs-lisp :tangle yes
(global-set-key (kbd "C-c h o") 'helm-occur)
#+END_SRC
*** eshell
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'eshell-mode-hook
	    #'(lambda ()
		(define-key eshell-mode-map (kbd "C-c C-l")  'helm-eshell-history)))
;(require 'helm-eshell)
;(add-hook 'eshell-mode-hook
;          #'(lambda ()
;              (define-key eshell-mode-map (kbd "C-c C-l")  'helm-eshell-history)))

#+END_SRC
*** mini-buffer
#+BEGIN_SRC emacs-lisp :tangle yes
(define-key minibuffer-local-map (kbd "C-c C-l") 'helm-minibuffer-history)
#+END_SRC

* Load All
#+BEGIN_SRC emacs-lisp :tangle yes
  (print "Finish")
#+END_SRC

* Tutorial
** Table
*** Chapter 20 yanking
*** Chapter 21 web mode
*** Chapter 22 emacsclient
*** Chapter 23 capture
*** Chapter 24 links
*** Chapter 25 tramp
*** Chapter 26 Google Calendar sync and Org Agenda
*** Chapter 27 shell and eshell
*** Chapter 28 Rectangle
*** Chapter 29 elfeed
skip it's rss reader plugin I do not use it often
*** Chapter 30 elfeed and hydras
skip it's rss reader plugin I do not use it often
*** Chapter 31 elfeed and macros
skip it's rss reader plugin I do not use it often
*** Chapter 32 emacs C+++
*** Chapter 33 projectile and dumb-jump
*** Chapter 34 IBuffer and Emmet mode
*** Chapter 35 Blogging
*** Chapter 36 A touch of elisp
*** Chapter 47 Magit
*** Chapter 54 Org Tables
*** Chapter 57 dired 
